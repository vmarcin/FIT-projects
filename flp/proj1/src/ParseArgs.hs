module ParseArgs (parseArgs) where

import Data.List
import Data.Maybe

usage = "Usage: plg-2-nka options [input]\n \
         \\t\t-i -- the loaded PLG which was converted to the internal representation is written to stdout.\n\
         \\t\t-1 -- the grammar in the form defined in the sentence 3.2 (from the script of the TIN subject) is printed.\n\
         \\t\t-2 -- an NKA that accepts the same language as that generated by the input grammar is printed.\n"

-- definition of acceptable rules
options = ["-i", "-1", "-2"]
optionsDefault = [False, False, False] 

getArgIndex :: String -> Int
getArgIndex opt = fromMaybe (-1) $ elemIndex opt options

setNthArg :: Int -> Bool -> [Bool] -> [Bool]
setNthArg _ _ [] = []
setNthArg n newVal (x:xs)
    | n == -1 = optionsDefault
    | n == 0 = newVal:xs
    | otherwise = x:setNthArg (n-1) newVal xs

-- It recognizes input arguments and in case of an error halts the program and prints usage.
-- Returns list of bools which tells us about given args e.g. [True,False,False] means
-- that only -i argument was given. Function also returns a name of an input file if given.
parseArgs :: [String] -> ([Bool], String)
parseArgs [] = error usage
parseArgs args =
    case args of
        -- one arg given - recognize and return or error 
        [x] 
            | x `elem` options 
            -> (setNthArg (getArgIndex x) True optionsDefault, [])
            | otherwise -> error usage
        -- two args given. either [-arg -arg] or [-arg input] or error
        [x, y] 
            | (x `elem` options) && (y `elem` options) 
            ->  (setNthArg (getArgIndex y) True $ 
                    setNthArg (getArgIndex x) True optionsDefault, [])
            | x `elem` options 
            ->  (setNthArg (getArgIndex x) True optionsDefault, y)
            | otherwise -> error usage
        -- three args given. either [-arg -arg -arg] or [-arg -arg input] or error
        [x, y, z] 
            | (x `elem` options) && (y `elem` options) && (z `elem` options)
            ->  (setNthArg (getArgIndex z) True $ 
                    setNthArg (getArgIndex y) True $ 
                    setNthArg (getArgIndex x) True optionsDefault, [])
            | (x `elem` options) && (y `elem` options) 
            ->  (setNthArg (getArgIndex y) True $
                    setNthArg (getArgIndex x) True optionsDefault, z)
            | otherwise 
            -> error usage
        -- four args given. either [-arg -arg -arg input] or error
        [x, y, z, q] 
            | (x `elem` options) && (y `elem` options) && (z `elem` options)
            ->  (setNthArg (getArgIndex z) True $ 
                    setNthArg (getArgIndex y) True $ 
                    setNthArg (getArgIndex x) True optionsDefault, q)
            | otherwise
            -> error usage
        -- more than four args given = always error
        _ -> error usage